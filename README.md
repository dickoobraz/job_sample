# job_sample

This is a sample nodejs app

Дано:
Есть абстрактное NodeJS-приложение, обслуживающее HTTP-запросы и хранящее данные в MySQL. Параметры подключения к MySQL и HTTP-порт задаются через переменные окружения. Сборка приложения выполняется командами `npm install && npm run build`, запуск - командой `node dist/main.js`.

Задача: 
1. Описать сборку и развертывание N экземпляров такого приложения в Kubernetes (с балансировкой входящих запросов между экземплярами). 
2. Обеспечить централизованный сбор логов приложения из STDOUT/STDERR. 
3. Описать возможные подходы к мониторингу состояния приложения. 
Допускается использование любого подходящего инструментария.

Результат: 
Набор конфигурационных файлов и скриптов для решения поставленной задачи, а также README с описанием решения и инструкциями по его использованию.

1. Исходный код приложения находится в директории dist. Код позволяет выполнить запрос в БД, примерный дамп БД предоставлен в файле dump.mysql. Приложение пакуется с помощью Dockerfile и пушится в публичный DockerHub. Запуск приложения осуществляется с помощью helm, чарт для которого находится в директории helm_chart. Балансировка запросов к репликам приложения осуществляется через сущность LoadBalancer. В данном чарте включена и используется возможность Horizontal Pod Autoscaler которая, в зависимости от нагрузки на приложение, управляет количеством его дубликатов для обеспечения высокой доступности.

2. Для централизованного сбора логов из подов предлагаю выбрать из двух вариантов - стек EFK (Elasticsearch Fluentd Kibana) и loghouse (Fluentd, Clickhouse, webUI). Так как компания, по результатам беседы, уже эксплуатирует кластер Clickhouse и имеет опыт работы с ним, а так-же то, что Clickhouse обеспечивает меньший оверхед в случае разворачивания его внутри кластера то предпочтительным становится использование именно этого решения для сбора логов. Установка данной системы сбора логов происходит очень просто с помощью публичного helm-chart https://github.com/flant/loghouse

3. Мониторинг предлагается осуществлять с помощью Prometheus. Для визуализации метрик - Grafana. Для улучшения полноты мониторинга самые критичные параметры приложения выводить в отдельный endpoint в формате OpenMetrics (например факт использования определенных роутов, результат их выполнения, время на выполнение и пр.). Для контроля связности между зависимыми сервисами приложения и визуализации задержек применить Jaeger. Для команды разработки следует прописать манифест, согласно которому будет писаться поддержка мониторинга в выпускаемом продукте.
